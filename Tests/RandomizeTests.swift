import Testing
import Foundation
import UIKit
@testable import RandomizerCore
@testable import RandomizeMacro

@Suite("Randomizable basic behavior")
struct RandomizableTests {
    
    @Test("Int random within bounds")
    func intRandomWithinBounds() throws {
        let lower = 10
        let upper = 20
        let value = Int.random(in: lower..<upper)
        #expect(value >= lower && value < upper)
    }
    
    @Test("Double random within bounds")
    func doubleRandomWithinBounds() throws {
        let lower: Double = 1.5
        let upper: Double = 3.25
        let value = Double.random(in: lower..<upper)
        #expect(value >= lower && value < upper)
    }
    
    @Test("Float random within bounds")
    func floatRandomWithinBounds() throws {
        let lower: Float = -5
        let upper: Float = 5
        let value = Float.random(in: lower..<upper)
        #expect(value >= lower && value < upper)
    }
    
    @Test("CGFloat random within bounds")
    func cgFloatRandomWithinBounds() throws {
        let lower: CGFloat = 2
        let upper: CGFloat = 4
        let value = CGFloat.random(in: lower..<upper)
        #expect(value >= lower && value < upper)
    }
    
    @Test("String random length between bounds' lengths")
    func stringRandomLengthWithinBounds() throws {
        let shorter = "a"
        let longer = String(repeating: "b", count: 10)
        let value = String.random(in: shorter..<longer)
        #expect(value.count >= shorter.count && value.count < longer.count)
    }
    
    @Test("String returns lower when lengths equal")
    func stringEqualLengthReturnsLower() throws {
        let a = "abc"
        let b = "def" // same length
        let value = String.random(in: a..<b)
        #expect(value == a)
    }
    
    @Test("Date random within bounds")
    func dateRandomWithinBounds() throws {
        let lower = Date(timeIntervalSince1970: 1_000)
        let upper = Date(timeIntervalSince1970: 2_000)
        let value = Date.random(in: lower..<upper)
        #expect(value >= lower && value < upper)
    }
    
    @Test("CGSize random within bounds per component")
    func cgSizeRandomWithinBounds() throws {
        let lower = CGSize(width: 10, height: 20)
        let upper = CGSize(width: 30, height: 40)
        let value = CGSize.random(in: lower..<upper)
        #expect(value.width >= lower.width && value.width < upper.width)
        #expect(value.height >= lower.height && value.height < upper.height)
    }
    
    @Test("CGPoint random within bounds per component")
    func cgPointRandomWithinBounds() throws {
        let lower = CGPoint(x: -10, y: -20)
        let upper = CGPoint(x: 10, y: 20)
        let value = CGPoint.random(in: lower..<upper)
        #expect(value.x >= lower.x && value.x < upper.x)
        #expect(value.y >= lower.y && value.y < upper.y)
    }
}

@Suite("Range convenience extensions")
struct RangeRandomTests {
    
    @Test
    func intRangeRandom() throws {
        let r = 1..<5
        let v = Int.random()
        #expect(v >= r.lowerBound && v < r.upperBound)
    }
    
    @Test
    func doubleRangeRandom() throws {
        let r: Range<Double> = 0.5..<1.5
        let v = Double.random()
        #expect(v >= r.lowerBound && v < r.upperBound)
    }
    
    @Test
    func floatRangeRandom() throws {
        let r: Range<Float> = -2..<2
        let v = Float.random()
        #expect(v >= r.lowerBound && v < r.upperBound)
    }
    
    @Test
    func cgFloatRangeRandom() throws {
        let r: Range<CGFloat> = 10..<12
        let v = CGFloat.random()
        #expect(v >= r.lowerBound && v < r.upperBound)
    }
}


// MARK: - Macro-driven structs for testing
@Suite("Macro-driven Randomize expansions")
struct RandomizeMacroGenerationTests {
    @Randomize
    struct Custom {
        @Randomizable(in: 1..<3) let name: String
        @Randomizable(in: 5..<10) let information: String
    }
    
    @Randomize
    struct Holder {
        @Randomizable(in: -100..<100) let int: Int
        @Randomizable(in: -1.0..<1.0) let double: Double
        @Unrandomizable let skip: String = ""
        let image: UIImage
        let custom: Custom
    }
    
    @Test("Holder.random() produces values within the declared ranges")
    func holderRandomProducesValuesWithinBounds() throws {
        let holder = Holder.random()
        // Int in inclusive closed range
        #expect(holder.int >= -100 && holder.int <= 100)
        // Double in inclusive closed range
        #expect(holder.double >= -1.0 && holder.double <= 1.0)
        // Custom fields generated by Custom.random() should respect their ranges
        #expect(holder.custom.name.count >= 1 && holder.custom.name.count <= 3)
        #expect(holder.custom.information.count >= 5 && holder.custom.information.count <= 10)
    }
    
    @Test("Generated types conform to Randomizable")
    func typesConformToRandomizable() throws {
        // Compile-time conformance check via a generic helper
        func assertConforms<T>(_ type: T.Type) where T: Randomizable {}
        assertConforms(Holder.self)
        assertConforms(Custom.self)
        #expect(true)
    }
    
    @Test("@Unrandomizable field keeps its default value")
    func unrandomizableKeepsDefault() throws {
        let holder = Holder.random()
        #expect(holder.skip == "")
    }
    
    @Test("Image field is present and created")
    func imageFieldIsPresent() throws {
        let holder = Holder.random()
        // UIImage is a reference type-like value; here we only check it's not an empty placeholder
        // Minimal check: size is non-negative (if the macro produces it this way), or at least not a 0x0 image
        #expect(holder.image.size.width >= 0)
        #expect(holder.image.size.height >= 0)
    }
    
    @Test("Custom.random() also stays within the declared ranges")
    func customRandomWithinBounds() throws {
        let c = Custom.random()
        #expect(c.name.count >= 1 && c.name.count <= 3)
        #expect(c.information.count >= 5 && c.information.count <= 10)
    }
    
    @Test("Multiple random() calls produce variety")
    func multipleRandomCallsProduceVariety() throws {
        var seenInts = Set<Int>()
        var seenDoubles = [Double]()
        for _ in 0..<10 {
            let h = Holder.random()
            seenInts.insert(h.int)
            seenDoubles.append(h.double)
        }
        #expect(seenInts.count > 1)
        // Verify doubles are not all identical (extremely unlikely by chance)
        let allSameDouble = seenDoubles.allSatisfy { $0 == seenDoubles.first }
        #expect(!allSameDouble)
    }
    //
    //    @Test("Deterministic generation with the same seed (if supported)")
    //    func deterministicWithSeedIfSupported() throws {
    //        // If the macro/library provides a seeded API, use it; otherwise skip this test.
    //        // Assumed API shapes (at least one might exist in the project):
    //        // 1) Holder.random(using:) where the parameter is an inout RandomNumberGenerator
    //        // 2) Holder.random(seed: UInt64)
    //        // 3) Holder.random(generator: inout some RandomNumberGenerator)
    //        
    //        // 1) inout RNG sample
    //        struct FixedSeedRNG: RandomNumberGenerator {
    //            var rng: any RandomNumberGenerator
    //            init(seed: UInt64) {
    //                self.rng = SeededGenerator(seed: seed)
    //            }
    //            mutating func next() -> UInt64 { rng.next() }
    //        }
    //        
    //        // SeededGenerator fallback definition for compilation only; if the project already has one, this won't be used.
    //        struct SeededGenerator: RandomNumberGenerator {
    //            private var state: UInt64
    //            init(seed: UInt64) { self.state = seed == 0 ? 0xdeadbeef : seed }
    //            mutating func next() -> UInt64 {
    //                // Xorshift64*
    //                var x = state
    //                x &*= 2685821657736338717
    //                x ^= x >> 12
    //                x ^= x << 25
    //                x ^= x >> 27
    //                state = x
    //                return x
    //            }
    //        }
    //        
    //        var g1 = FixedSeedRNG(seed: 42)
    //        var g2 = FixedSeedRNG(seed: 42)
    //        // The following only compiles if the API exists. Try multiple variants and conditionally verify consistency.
    //        // Try the random(using:) variant first.
    //        if let h1: Holder? = ({
    //            // Swift doesn't support reflective checks here; call it and if it compiles, use it.
    //            // Compilation determines which branch is available.
    //            return Holder.random(using: &g1)
    //        }()) {
    //            let h2 = Holder.random(using: &g2)
    //            #expect(h1.int == h2.int)
    //            #expect(h1.double == h2.double)
    //            #expect(h1.custom.name == h2.custom.name)
    //            #expect(h1.custom.information == h2.custom.information)
    //            return
    //        }
    //        
    //        // If there's no using: API, try the seed parameter variant.
    //        do {
    //            let h1 = Holder.random(seed: 42)
    //            let h2 = Holder.random(seed: 42)
    //            #expect(h1.int == h2.int)
    //            #expect(h1.double == h2.double)
    //            #expect(h1.custom.name == h2.custom.name)
    //            #expect(h1.custom.information == h2.custom.information)
    //            return
    //        }
    //        
    //        // If neither API exists, pass the test with a trivial true, indicating seeded determinism isn't supported.
    //        #expect(true, "Seeded deterministic API not available; test skipped")
    //    }
    //
    //    @Test("Boundary checks near min and max")
    //    func boundaryValuesNearEdges() throws {
    //        // We can't force exact extremes directly, but repeated generation gives them a chance.
    //        // Instead, assert that values NEVER exceed their declared limits.
    //        for _ in 0..<100 {
    //            let h = Holder.random()
    //            #expect(h.int >= -100 && h.int <= 100)
    //            #expect(h.double >= -1.0 && h.double <= 1.0)
    //            #expect(h.custom.name.count >= 1 && h.custom.name.count <= 3)
    //            #expect(h.custom.information.count >= 5 && h.custom.information.count <= 10)
    //        }
    //    }
}
